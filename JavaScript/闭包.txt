闭包：

    高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。 闭包是由函数以及声明该函数的词法环境组合而成的

    新声明的变量 = func时，新声明的变量就指向了func的内部函数

    使用场景：不需要立即返回求和的结果
             通常你使用只有一个方法的对象的地方，都可以使用闭包
             在web中使用：我们大部分的js代码是在基于事件的---定义某种行为，将其添加到用户触发的事件之上（回调：为响应事件而执行的函数）
             -----自己理解：先定义函数指向闭包函数，并给上相关的参数，只是还不执行，在添加到用户的行为时候执行该函数
             模拟私有方法（js中没有这种的原生支持）：利于限制对代码的访问
             每个闭包都是引用自己词法作用域内的变量，在一个闭包内对变量的修改，不会影响到另外一个闭包的变量
            

    使用注意事项：
                不能把闭包嵌入在循环里面使用，因为在你调用函数的时候，循环已经执行完毕；循环中的变量已经指向了最后一个
                for (var i = 0; i < helpText.length; i++) {
                    var item = helpText[i];
                    document.getElementById(item.id).onfocus = function() {
                    showHelp(item.help);
                    }
                }
                解决办法：
                1、使用更多的闭包，给每一个回调创建一个新的词法环境
                for (var i = 0; i < helpText.length; i++) {
                    var item = helpText[i];
                    document.getElementById(item.id).onfocus = makeHelpCallback(item.help);
                }
                2、使用匿名函数，把当前循环项和事件回调相关联起来
                3、如果不想使用过多的闭包，可以使用let关键字，let和var的区别？？？？

    闭包的缺点：
            在处理速度和内存消耗方面对脚本的性能有负面影响